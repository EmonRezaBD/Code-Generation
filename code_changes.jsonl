{"code": "@@ -681,10 +681,15 @@ function lengthBytesUTF8(str) {"}
{"code": ""}
{"code": "var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;"}
{"code": "function UTF16ToString(ptr) {"}
{"code": "#if ASSERTIONS"}
{"code": "assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');"}
{"code": "#endif"}
{"code": "var endPtr = ptr;"}
{"code": "// TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself."}
{"code": "// Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage."}
{"code": "while ({{{ makeGetValue('endPtr', 0, 'i16') }}}) endPtr += 2;"}
{"code": "var idx = endPtr >> 1;"}
{"code": "while (HEAP16[idx]) ++idx;"}
{"code": "endPtr = idx << 1;"}
{"code": ""}
{"code": "if (endPtr - ptr > 32 && UTF16Decoder) {"}
{"code": "return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));"}
{"code": "@@ -715,6 +720,9 @@ function UTF16ToString(ptr) {"}
{"code": "// Returns the number of bytes written, EXCLUDING the null terminator."}
{"code": ""}
{"code": "function stringToUTF16(str, outPtr, maxBytesToWrite) {"}
{"code": "#if ASSERTIONS"}
{"code": "assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');"}
{"code": "#endif"}
{"code": "#if ASSERTIONS"}
{"code": "assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');"}
{"code": "#endif"}
{"code": "@@ -746,6 +754,9 @@ function lengthBytesUTF16(str) {"}
{"code": "{{{ maybeExport('lengthBytesUTF16') }}}"}
{"code": ""}
{"code": "function UTF32ToString(ptr) {"}
{"code": "#if ASSERTIONS"}
{"code": "assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');"}
{"code": "#endif"}
{"code": "var i = 0;"}
{"code": ""}
{"code": "var str = '';"}
{"code": "@@ -778,6 +789,9 @@ function UTF32ToString(ptr) {"}
{"code": "// Returns the number of bytes written, EXCLUDING the null terminator."}
{"code": ""}
{"code": "function stringToUTF32(str, outPtr, maxBytesToWrite) {"}
{"code": "#if ASSERTIONS"}
{"code": "assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');"}
{"code": "#endif"}
{"code": "#if ASSERTIONS"}
{"code": "assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');"}
{"code": "#endif"}
{"code": ""}
