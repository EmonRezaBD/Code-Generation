{"Commit title": "sceKernelFindModuleByName:Add delay for Fake module", "only_addition_codes": "if(strcmp(name, module->nm.name) ==0) {\nif(!module->isFake) {\nINFO_LOG(SCEMODULE,\"%d = sceKernelFindModuleByName(%s)\", module->modulePtr, name);\nreturnmodule->modulePtr;\n}\nelse{\nWARN_LOG(SCEMODULE,\"0 = sceKernelFindModuleByName(%s): Module Fake\", name);\nreturnhleDelayResult(0,\"Module Fake\",1000*1000);\n}\nWARN_LOG(SCEMODULE,\"0 = sceKernelFindModuleByName(%s): Module Not Found\", name);", "only_deletion_codes": "if(!module->isFake&&strcmp(name, module->nm.name) ==0) {\nINFO_LOG(SCEMODULE,\"%d = sceKernelFindModuleByName(%s)\", module->modulePtr, name);\nreturnmodule->modulePtr;\nWARN_LOG(SCEMODULE,\"0 = sceKernelFindModuleByName(%s): Module Not Foundor Fake\", name);", "codes_without_addition_and_deletion": "PSPModule *module = kernelObjects.Get<PSPModule>(moduleId, error);\nif(!module)\ncontinue;\n}\n}\nreturn0;\n}\n", "before_commit_codebase": "PSPModule *module = kernelObjects.Get<PSPModule>(moduleId, error);\nif(!module)\ncontinue;\nif(!module->isFake&&strcmp(name, module->nm.name) ==0) {\nINFO_LOG(SCEMODULE,\"%d = sceKernelFindModuleByName(%s)\", module->modulePtr, name);\nreturnmodule->modulePtr;\n}\n}\nWARN_LOG(SCEMODULE,\"0 = sceKernelFindModuleByName(%s): Module Not Foundor Fake\", name);\nreturn0;\n}\n", "after_commit_codebase": "PSPModule *module = kernelObjects.Get<PSPModule>(moduleId, error);\nif(!module)\ncontinue;\nif(strcmp(name, module->nm.name) ==0) {\nif(!module->isFake) {\nINFO_LOG(SCEMODULE,\"%d = sceKernelFindModuleByName(%s)\", module->modulePtr, name);\nreturnmodule->modulePtr;\n}\nelse{\nWARN_LOG(SCEMODULE,\"0 = sceKernelFindModuleByName(%s): Module Fake\", name);\nreturnhleDelayResult(0,\"Module Fake\",1000*1000);\n}\n}\n}\nWARN_LOG(SCEMODULE,\"0 = sceKernelFindModuleByName(%s): Module Not Found\", name);\nreturn0;\n}\n"}
{"Commit title": "Add the slow comment to one more place", "only_addition_codes": "//NOTE: Reading the decoded texture here may be very slow, if we just wrote it to write-combined memory.", "only_deletion_codes": "", "codes_without_addition_and_deletion": "//When hardware texture scaling is enabled, this saves the original.\nintw = dataScaled ? mipWidth : mipUnscaledWidth;\ninth = dataScaled ? mipHeight : mipUnscaledHeight;\nreplacer_.NotifyTextureDecoded(replacedInfo, data, stride, i, w, h);\n}\n}", "before_commit_codebase": "//When hardware texture scaling is enabled, this saves the original.\nintw = dataScaled ? mipWidth : mipUnscaledWidth;\ninth = dataScaled ? mipHeight : mipUnscaledHeight;\nreplacer_.NotifyTextureDecoded(replacedInfo, data, stride, i, w, h);\n}\n}", "after_commit_codebase": "//When hardware texture scaling is enabled, this saves the original.\nintw = dataScaled ? mipWidth : mipUnscaledWidth;\ninth = dataScaled ? mipHeight : mipUnscaledHeight;\n//NOTE: Reading the decoded texture here may be very slow, if we just wrote it to write-combined memory.\nreplacer_.NotifyTextureDecoded(replacedInfo, data, stride, i, w, h);\n}\n}"}
{"Commit title": "UI: Prevent save textures if not replacing.", "only_addition_codes": "list->Add(newCheckBox(&g_Config.bSaveNewTextures, dev->T(\"Save new textures\")))->SetEnabledPtr(&g_Config.bReplaceTextures);", "only_deletion_codes": "list->Add(newCheckBox(&g_Config.bSaveNewTextures, dev->T(\"Save new textures\")));", "codes_without_addition_and_deletion": "list->Add(newChoice(dev->T(\"Load language ini\")))->OnClick.Handle(this, &DeveloperToolsScreen::OnLoadLanguageIni);\nlist->Add(newChoice(dev->T(\"Save language ini\")))->OnClick.Handle(this, &DeveloperToolsScreen::OnSaveLanguageIni);\nlist->Add(newItemHeader(dev->T(\"Texture Replacement\")));\nlist->Add(newCheckBox(&g_Config.bReplaceTextures, dev->T(\"Replace textures\")));\n\n//Makes it easy to get savestates out of an iOS device. The file listing shown in MacOS doesn't allow", "before_commit_codebase": "list->Add(newChoice(dev->T(\"Load language ini\")))->OnClick.Handle(this, &DeveloperToolsScreen::OnLoadLanguageIni);\nlist->Add(newChoice(dev->T(\"Save language ini\")))->OnClick.Handle(this, &DeveloperToolsScreen::OnSaveLanguageIni);\nlist->Add(newItemHeader(dev->T(\"Texture Replacement\")));\nlist->Add(newCheckBox(&g_Config.bSaveNewTextures, dev->T(\"Save new textures\")));\nlist->Add(newCheckBox(&g_Config.bReplaceTextures, dev->T(\"Replace textures\")));\n\n//Makes it easy to get savestates out of an iOS device. The file listing shown in MacOS doesn't allow", "after_commit_codebase": "list->Add(newChoice(dev->T(\"Load language ini\")))->OnClick.Handle(this, &DeveloperToolsScreen::OnLoadLanguageIni);\nlist->Add(newChoice(dev->T(\"Save language ini\")))->OnClick.Handle(this, &DeveloperToolsScreen::OnSaveLanguageIni);\nlist->Add(newItemHeader(dev->T(\"Texture Replacement\")));\nlist->Add(newCheckBox(&g_Config.bSaveNewTextures, dev->T(\"Save new textures\")))->SetEnabledPtr(&g_Config.bReplaceTextures);\nlist->Add(newCheckBox(&g_Config.bReplaceTextures, dev->T(\"Replace textures\")));\n\n//Makes it easy to get savestates out of an iOS device. The file listing shown in MacOS doesn't allow"}
{"Commit title": "Replacement: Be more consistent about base level.", "only_addition_codes": "actualFmt =ToVulkanFormat(plan.replaced->Format(plan.baseLevelSrc));\nplan.replaced->GetSize(plan.baseLevelSrc+i, mipWidth, mipHeight);\nplan.replaced->Load(plan.baseLevelSrc+i, data, stride);//if it fails, it'll just be garbage data... OK for now.\nreplacer_.NotifyTextureDecoded(replacedInfo, data, stride,plan.baseLevelSrc+i, w, h);", "only_deletion_codes": "actualFmt =ToVulkanFormat(plan.replaced->Format(0));\nplan.replaced->GetSize(i, mipWidth, mipHeight);\nplan.replaced->Load(i, data, stride);//if it fails, it'll just be garbage data... OK for now.\nreplacer_.NotifyTextureDecoded(replacedInfo, data, stride, i, w, h);", "codes_without_addition_and_deletion": "//Any texture scaling is gonna move away from the original 16-bit format, if any.\nVkFormat actualFmt = plan.scaleFactor>1? VULKAN_8888_FORMAT : dstFmt;\nif(plan.replaced->Valid()) {\n}\n\nboolcomputeUpload =false;\nintmipWidth = mipUnscaledWidth * plan.scaleFactor;\nintmipHeight = mipUnscaledHeight * plan.scaleFactor;\nif(plan.replaced->Valid()) {\n}\n\nintbpp = actualFmt == VULKAN_8888_FORMAT ?4:2;//output bpp\n//Directly load the replaced image.\ndata = drawEngine_->GetPushBufferForTextureData()->PushAligned(size, &bufferOffset, &texBuf, pushAlignment);\ndoublereplaceStart =time_now_d();\nreplacementTimeThisFrame_ +=time_now_d() - replaceStart;\nVK_PROFILE_BEGIN(vulkan, cmdInit, VK_PIPELINE_STAGE_TRANSFER_BIT,\n\"Copy Upload (replaced): %dx%d\", mipWidth, mipHeight);\nintw = dataScaled ? mipWidth : mipUnscaledWidth;\ninth = dataScaled ? mipHeight : mipUnscaledHeight;\n//At this point, data should be saveData, and not slow.\n}\n}\n}", "before_commit_codebase": "//Any texture scaling is gonna move away from the original 16-bit format, if any.\nVkFormat actualFmt = plan.scaleFactor>1? VULKAN_8888_FORMAT : dstFmt;\nif(plan.replaced->Valid()) {\nactualFmt =ToVulkanFormat(plan.replaced->Format(0));\n}\n\nboolcomputeUpload =false;\nintmipWidth = mipUnscaledWidth * plan.scaleFactor;\nintmipHeight = mipUnscaledHeight * plan.scaleFactor;\nif(plan.replaced->Valid()) {\nplan.replaced->GetSize(i, mipWidth, mipHeight);\n}\n\nintbpp = actualFmt == VULKAN_8888_FORMAT ?4:2;//output bpp\n//Directly load the replaced image.\ndata = drawEngine_->GetPushBufferForTextureData()->PushAligned(size, &bufferOffset, &texBuf, pushAlignment);\ndoublereplaceStart =time_now_d();\nplan.replaced->Load(i, data, stride);//if it fails, it'll just be garbage data... OK for now.\nreplacementTimeThisFrame_ +=time_now_d() - replaceStart;\nVK_PROFILE_BEGIN(vulkan, cmdInit, VK_PIPELINE_STAGE_TRANSFER_BIT,\n\"Copy Upload (replaced): %dx%d\", mipWidth, mipHeight);\nintw = dataScaled ? mipWidth : mipUnscaledWidth;\ninth = dataScaled ? mipHeight : mipUnscaledHeight;\n//At this point, data should be saveData, and not slow.\nreplacer_.NotifyTextureDecoded(replacedInfo, data, stride, i, w, h);\n}\n}\n}", "after_commit_codebase": "//Any texture scaling is gonna move away from the original 16-bit format, if any.\nVkFormat actualFmt = plan.scaleFactor>1? VULKAN_8888_FORMAT : dstFmt;\nif(plan.replaced->Valid()) {\nactualFmt =ToVulkanFormat(plan.replaced->Format(plan.baseLevelSrc));\n}\n\nboolcomputeUpload =false;\nintmipWidth = mipUnscaledWidth * plan.scaleFactor;\nintmipHeight = mipUnscaledHeight * plan.scaleFactor;\nif(plan.replaced->Valid()) {\nplan.replaced->GetSize(plan.baseLevelSrc+i, mipWidth, mipHeight);\n}\n\nintbpp = actualFmt == VULKAN_8888_FORMAT ?4:2;//output bpp\n//Directly load the replaced image.\ndata = drawEngine_->GetPushBufferForTextureData()->PushAligned(size, &bufferOffset, &texBuf, pushAlignment);\ndoublereplaceStart =time_now_d();\nplan.replaced->Load(plan.baseLevelSrc+i, data, stride);//if it fails, it'll just be garbage data... OK for now.\nreplacementTimeThisFrame_ +=time_now_d() - replaceStart;\nVK_PROFILE_BEGIN(vulkan, cmdInit, VK_PIPELINE_STAGE_TRANSFER_BIT,\n\"Copy Upload (replaced): %dx%d\", mipWidth, mipHeight);\nintw = dataScaled ? mipWidth : mipUnscaledWidth;\ninth = dataScaled ? mipHeight : mipUnscaledHeight;\n//At this point, data should be saveData, and not slow.\nreplacer_.NotifyTextureDecoded(replacedInfo, data, stride,plan.baseLevelSrc+i, w, h);\n}\n}\n}"}
{"Commit title": "Add a heuristic avoiding joining framebuffers horizontally", "only_addition_codes": "//If the framebuffer we can join to is currently bound as a texture, we likely have\n//a situation like in #9324 and don't want to do this.\nu32 curTextureAddress = gstate.getTextureAddress(0);\nif(v->fb_address== curTextureAddress) {\n//Don't try these joining shenanigans.\ncontinue;\n}\n", "only_deletion_codes": "", "codes_without_addition_and_deletion": "u32 v_fb_end_ptr = v->fb_address+ v->fb_stride* v->height* bpp;\n\nif(params.fb_address> v->fb_address&& params.fb_address< v_fb_first_line_end_ptr) {\nconstintx_offset = (params.fb_address- v->fb_address) / bpp;\nif(x_offset < params.fb_stride&& v->height>= drawing_height) {\n//Pretty certainly a pure render-to-X-offset.", "before_commit_codebase": "u32 v_fb_end_ptr = v->fb_address+ v->fb_stride* v->height* bpp;\n\nif(params.fb_address> v->fb_address&& params.fb_address< v_fb_first_line_end_ptr) {\nconstintx_offset = (params.fb_address- v->fb_address) / bpp;\nif(x_offset < params.fb_stride&& v->height>= drawing_height) {\n//Pretty certainly a pure render-to-X-offset.", "after_commit_codebase": "u32 v_fb_end_ptr = v->fb_address+ v->fb_stride* v->height* bpp;\n\nif(params.fb_address> v->fb_address&& params.fb_address< v_fb_first_line_end_ptr) {\n//If the framebuffer we can join to is currently bound as a texture, we likely have\n//a situation like in #9324 and don't want to do this.\nu32 curTextureAddress = gstate.getTextureAddress(0);\nif(v->fb_address== curTextureAddress) {\n//Don't try these joining shenanigans.\ncontinue;\n}\n\nconstintx_offset = (params.fb_address- v->fb_address) / bpp;\nif(x_offset < params.fb_stride&& v->height>= drawing_height) {\n//Pretty certainly a pure render-to-X-offset."}
{"Commit title": "Remove a useless debug message in filetransfer.cc", "only_addition_codes": "", "only_deletion_codes": "debug(\"verify TLS: Nix CA file = '%s'\", settings.caFile);", "codes_without_addition_and_deletion": "}\n\nif(request.verifyTLS) {\nif(settings.caFile!=\"\")\ncurl_easy_setopt(req, CURLOPT_CAINFO, settings.caFile.c_str());\n}else{", "before_commit_codebase": "}\n\nif(request.verifyTLS) {\ndebug(\"verify TLS: Nix CA file = '%s'\", settings.caFile);\nif(settings.caFile!=\"\")\ncurl_easy_setopt(req, CURLOPT_CAINFO, settings.caFile.c_str());\n}else{", "after_commit_codebase": "}\n\nif(request.verifyTLS) {\nif(settings.caFile!=\"\")\ncurl_easy_setopt(req, CURLOPT_CAINFO, settings.caFile.c_str());\n}else{"}
{"Commit title": "+ fix: go to doc begin after global indentation change", "only_addition_codes": "\nSci_GotoPosChooseCaret(0);\n", "only_deletion_codes": "DocPosconstiCurPos=SciCall_GetCurrentPos();\n\nSci_GotoPosChooseCaret(iCurPos);\n", "codes_without_addition_and_deletion": "boolconstbackSpcUnindents=SciCall_GetBackSpaceUnIndents();\nSciCall_SetBackSpaceUnIndents(true);\n\nUndoTransActionBegin();\nEditIndentBlock(Globals.hwndEdit,SCI_TAB, true, true);\nEditIndentBlock(Globals.hwndEdit,SCI_BACKTAB, true, true);\nEndUndoTransAction();\n\nSciCall_SetUseTabs(useTabs);\nSciCall_SetTabIndents(tabIndents);\nSciCall_SetBackSpaceUnIndents(backSpcUnindents);\n}else{\nstatus->iGlobalIndent=I_MIX_LN;\nreturnfalse;", "before_commit_codebase": "boolconstbackSpcUnindents=SciCall_GetBackSpaceUnIndents();\nSciCall_SetBackSpaceUnIndents(true);\n\nDocPosconstiCurPos=SciCall_GetCurrentPos();\n\nUndoTransActionBegin();\nEditIndentBlock(Globals.hwndEdit,SCI_TAB, true, true);\nEditIndentBlock(Globals.hwndEdit,SCI_BACKTAB, true, true);\nEndUndoTransAction();\n\nSci_GotoPosChooseCaret(iCurPos);\n\nSciCall_SetUseTabs(useTabs);\nSciCall_SetTabIndents(tabIndents);\nSciCall_SetBackSpaceUnIndents(backSpcUnindents);\n}else{\nstatus->iGlobalIndent=I_MIX_LN;\nreturnfalse;", "after_commit_codebase": "boolconstbackSpcUnindents=SciCall_GetBackSpaceUnIndents();\nSciCall_SetBackSpaceUnIndents(true);\n\nUndoTransActionBegin();\nEditIndentBlock(Globals.hwndEdit,SCI_TAB, true, true);\nEditIndentBlock(Globals.hwndEdit,SCI_BACKTAB, true, true);\nEndUndoTransAction();\n\nSciCall_SetUseTabs(useTabs);\nSciCall_SetTabIndents(tabIndents);\nSciCall_SetBackSpaceUnIndents(backSpcUnindents);\n\nSci_GotoPosChooseCaret(0);\n\n}else{\nstatus->iGlobalIndent=I_MIX_LN;\nreturnfalse;"}
{"Commit title": "change comment and cache value", "only_addition_codes": "//Returns the path theapplication root.\nstaticconststd::string root =uv::cwd();\nreturnroot;", "only_deletion_codes": "//Returns the pathtothedefault cache database on this system.\nreturnuv::cwd();", "codes_without_addition_and_deletion": "namespacembgl{\nnamespaceplatform{\n\nstd::stringapplicationRoot() {\n}\n\n}", "before_commit_codebase": "namespacembgl{\nnamespaceplatform{\n\n//Returns the pathtothedefault cache database on this system.\nstd::stringapplicationRoot() {\nreturnuv::cwd();\n}\n\n}", "after_commit_codebase": "namespacembgl{\nnamespaceplatform{\n\n//Returns the path theapplication root.\nstd::stringapplicationRoot() {\nstaticconststd::string root =uv::cwd();\nreturnroot;\n}\n\n}"}
{"Commit title": "fixes#621: better performance for iPhone 6 Plus through smaller rend…", "only_addition_codes": "if([UIScreeninstancesRespondToSelector:@selector(nativeScale)]) {\n_glView.contentScaleFactor= [[UIScreenmainScreen]nativeScale];\n}", "only_deletion_codes": "", "codes_without_addition_and_deletion": "_glView.enableSetNeedsDisplay=NO;\n_glView.drawableStencilFormat= GLKViewDrawableStencilFormat8;\n_glView.drawableDepthFormat= GLKViewDrawableDepthFormat16;\n_glView.delegate= self;\n[_glViewbindDrawable];\n[selfaddSubview:_glView];", "before_commit_codebase": "_glView.enableSetNeedsDisplay=NO;\n_glView.drawableStencilFormat= GLKViewDrawableStencilFormat8;\n_glView.drawableDepthFormat= GLKViewDrawableDepthFormat16;\n_glView.delegate= self;\n[_glViewbindDrawable];\n[selfaddSubview:_glView];", "after_commit_codebase": "_glView.enableSetNeedsDisplay=NO;\n_glView.drawableStencilFormat= GLKViewDrawableStencilFormat8;\n_glView.drawableDepthFormat= GLKViewDrawableDepthFormat16;\nif([UIScreeninstancesRespondToSelector:@selector(nativeScale)]) {\n_glView.contentScaleFactor= [[UIScreenmainScreen]nativeScale];\n}\n_glView.delegate= self;\n[_glViewbindDrawable];\n[selfaddSubview:_glView];"}
{"Commit title": "Replace regex usage with basic string manipulation", "only_addition_codes": "std::string::size_type queryIdx = url.rfind(\"?\");\n//Trim off the right end but never touch anything before the extension dot.\nstd::stringurlSansParams((queryIdx == std::string::npos) ? url : url.substr(0, queryIdx));\n\nwhile(!urlSansParams.empty() &&isdigit(urlSansParams.back()))\nurlSansParams.pop_back();\n\nstd::string::size_type extensionIdx = urlSansParams.length() -4;\nif(extensionIdx <=0)\nreturnurl;\nstd::string extension = urlSansParams.substr(extensionIdx);\nif(extension.compare(\".png\") !=0&& extension.compare(\".jpg\") !=0)\nreturnurl;\n\nstd::stringnormalizedURL(url);\nnormalizedURL.insert(extensionIdx,\"{ratio}\");\nreturnnormalizedURL;", "only_deletion_codes": "#include<regex>\nstaticstd::regexextension_re(\"\\\\.((?:png|jpg)\\\\d*)(?=$|\\\\?)\");\nreturnstd::regex_replace(url, extension_re,std::string(\"{ratio}.$1\"));", "codes_without_addition_and_deletion": "#include<mbgl/util/mapbox.hpp>\n\n#include<stdexcept>\n\nnamespacembgl{\nnamespaceutil{\nif(sourceURL.empty() || sourceURL.compare(0, mapbox.length(), mapbox) !=0)\nreturnurl;\n\n}\n\n}", "before_commit_codebase": "#include<mbgl/util/mapbox.hpp>\n\n#include<stdexcept>\n#include<regex>\n\nnamespacembgl{\nnamespaceutil{\nif(sourceURL.empty() || sourceURL.compare(0, mapbox.length(), mapbox) !=0)\nreturnurl;\n\nstaticstd::regexextension_re(\"\\\\.((?:png|jpg)\\\\d*)(?=$|\\\\?)\");\nreturnstd::regex_replace(url, extension_re,std::string(\"{ratio}.$1\"));\n}\n\n}", "after_commit_codebase": "#include<mbgl/util/mapbox.hpp>\n\n#include<stdexcept>\n\nnamespacembgl{\nnamespaceutil{\nif(sourceURL.empty() || sourceURL.compare(0, mapbox.length(), mapbox) !=0)\nreturnurl;\n\nstd::string::size_type queryIdx = url.rfind(\"?\");\n//Trim off the right end but never touch anything before the extension dot.\nstd::stringurlSansParams((queryIdx == std::string::npos) ? url : url.substr(0, queryIdx));\n\nwhile(!urlSansParams.empty() &&isdigit(urlSansParams.back()))\nurlSansParams.pop_back();\n\nstd::string::size_type extensionIdx = urlSansParams.length() -4;\nif(extensionIdx <=0)\nreturnurl;\nstd::string extension = urlSansParams.substr(extensionIdx);\nif(extension.compare(\".png\") !=0&& extension.compare(\".jpg\") !=0)\nreturnurl;\n\nstd::stringnormalizedURL(url);\nnormalizedURL.insert(extensionIdx,\"{ratio}\");\nreturnnormalizedURL;\n}\n\n}"}
{"Commit title": "Disable all Sources when terminating", "only_addition_codes": "\n//Since we don't have a stylesheet anymore, this will disable all Sources and cancel\n//their associated requests.\nupdateSources();\nassert(activeSources.empty());\n\n//It's now safe to destroy/join the workers since there won't be any more callbacks that\n//could dispatch to the worker pool.", "only_deletion_codes": "activeSources.clear();", "codes_without_addition_and_deletion": "\n//Remove all of these to make sure they are destructed in the correct thread.\nstyle.reset();\nworkers.reset();\n\nterminating =true;\n", "before_commit_codebase": "\n//Remove all of these to make sure they are destructed in the correct thread.\nstyle.reset();\nworkers.reset();\nactiveSources.clear();\n\nterminating =true;\n", "after_commit_codebase": "\n//Remove all of these to make sure they are destructed in the correct thread.\nstyle.reset();\n\n//Since we don't have a stylesheet anymore, this will disable all Sources and cancel\n//their associated requests.\nupdateSources();\nassert(activeSources.empty());\n\n//It's now safe to destroy/join the workers since there won't be any more callbacks that\n//could dispatch to the worker pool.\nworkers.reset();\n\nterminating =true;\n"}
{"Commit title": "add worker cancellation test (failing)", "only_addition_codes": "\nTEST(Worker, WorkRequestCancelsImmediately) {\nRunLooploop(uv_default_loop());\n\nWorkerworker(1);\n\nloop.invoke([&] {\nstd::promise<void> started;\n//First worker item.\nWorkRequest request1 = worker.send([&] {\nusleep(10000);\nstarted.set_value();\n}, [&] {});\n\nWorkRequest request2 = worker.send([&] {\nADD_FAILURE() <<\"Second work item should not be invoked\";\n}, [&] {});\nrequest2.join();\n\nstarted.get_future().get();\nrequest1.join();\n\nloop.stop();\n});\n\nuv_run(uv_default_loop(), UV_RUN_DEFAULT);\n}", "only_deletion_codes": "", "codes_without_addition_and_deletion": "uv_run(uv_default_loop(), UV_RUN_DEFAULT);\nEXPECT_FALSE(didAfter);\n}", "before_commit_codebase": "uv_run(uv_default_loop(), UV_RUN_DEFAULT);\nEXPECT_FALSE(didAfter);\n}", "after_commit_codebase": "uv_run(uv_default_loop(), UV_RUN_DEFAULT);\nEXPECT_FALSE(didAfter);\n}\n\nTEST(Worker, WorkRequestCancelsImmediately) {\nRunLooploop(uv_default_loop());\n\nWorkerworker(1);\n\nloop.invoke([&] {\nstd::promise<void> started;\n//First worker item.\nWorkRequest request1 = worker.send([&] {\nusleep(10000);\nstarted.set_value();\n}, [&] {});\n\nWorkRequest request2 = worker.send([&] {\nADD_FAILURE() <<\"Second work item should not be invoked\";\n}, [&] {});\nrequest2.join();\n\nstarted.get_future().get();\nrequest1.join();\n\nloop.stop();\n});\n\nuv_run(uv_default_loop(), UV_RUN_DEFAULT);\n}"}
{"Commit title": "Deffer updateAnnotationTiles() if Source is not available", "only_addition_codes": "if(!style) {\nreturn;\n}\nSource* shapeAnnotationSource = style->getSource(shapeID);\n\n//Style not parsed yet\nif(!shapeAnnotationSource) {\nreturn;\n}\n\nshapeAnnotationSource->enabled=true;", "only_deletion_codes": "if(!style)return;\nstyle->getSource(shapeID)->enabled=true;", "codes_without_addition_and_deletion": "util::exclusive<AnnotationManager> annotationManager = data.getAnnotationManager();\nannotationManager->markStaleTiles(ids);\n\n\n//grab existing, single shape annotations source\nconstauto& shapeID = AnnotationManager::ShapeLayerID;\n\n//create (if necessary) layers and buckets for each shape\nfor(constauto&shapeAnnotationID : annotationManager->getOrderedShapeAnnotations()) {", "before_commit_codebase": "util::exclusive<AnnotationManager> annotationManager = data.getAnnotationManager();\nannotationManager->markStaleTiles(ids);\n\nif(!style)return;\n\n//grab existing, single shape annotations source\nconstauto& shapeID = AnnotationManager::ShapeLayerID;\nstyle->getSource(shapeID)->enabled=true;\n\n//create (if necessary) layers and buckets for each shape\nfor(constauto&shapeAnnotationID : annotationManager->getOrderedShapeAnnotations()) {", "after_commit_codebase": "util::exclusive<AnnotationManager> annotationManager = data.getAnnotationManager();\nannotationManager->markStaleTiles(ids);\n\nif(!style) {\nreturn;\n}\n\n//grab existing, single shape annotations source\nconstauto& shapeID = AnnotationManager::ShapeLayerID;\nSource* shapeAnnotationSource = style->getSource(shapeID);\n\n//Style not parsed yet\nif(!shapeAnnotationSource) {\nreturn;\n}\n\nshapeAnnotationSource->enabled=true;\n\n//create (if necessary) layers and buckets for each shape\nfor(constauto&shapeAnnotationID : annotationManager->getOrderedShapeAnnotations()) {"}
{"Commit title": "GLFW port now uses nudgeTransitions()", "only_addition_codes": "constboolneedsRerender = map->renderSync();\nmap->nudgeTransitions(needsRerender);", "only_deletion_codes": "map->renderSync();", "codes_without_addition_and_deletion": "glfwWaitEvents();\nconstbooldirty = !clean.test_and_set();\nif(dirty) {\n}\n}\n}", "before_commit_codebase": "glfwWaitEvents();\nconstbooldirty = !clean.test_and_set();\nif(dirty) {\nmap->renderSync();\n}\n}\n}", "after_commit_codebase": "glfwWaitEvents();\nconstbooldirty = !clean.test_and_set();\nif(dirty) {\nconstboolneedsRerender = map->renderSync();\nmap->nudgeTransitions(needsRerender);\n}\n}\n}"}
